"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRootKeysGroup = exports.throwError = exports.configValidator = exports.transformsValidator = exports.singleTransformValidator = exports.findDuplicatesAndSubsets = exports.unique = exports.preserveUndefined = exports.mergeDeep = exports.dissocPath = exports.assocPath = exports.path = exports.difference = exports.cloneDeep = exports._cloneDeep = exports.getCircularPath = exports.isEmpty = exports.isDate = exports.isString = exports.isIntegerString = exports.isPlainObject = exports.isArray = exports.isLength = exports.isObjectLike = void 0;
const constants_1 = require("../constants");
const types_1 = require("../types");
const isObjectLike = function (value) {
    return typeof value === 'object' && value !== null;
};
exports.isObjectLike = isObjectLike;
const isLength = function (value) {
    return typeof value === 'number' && value > -1 && value % 1 == 0 && value <= Number.MAX_SAFE_INTEGER;
};
exports.isLength = isLength;
exports.isArray = Array.isArray ||
    function (value) {
        return (0, exports.isLength)(value && value.length) && Object.prototype.toString.call(value) === '[object Array]';
    };
const isPlainObject = function (item) {
    return !!item && typeof item === 'object' && !(0, exports.isArray)(item);
};
exports.isPlainObject = isPlainObject;
const isIntegerString = function (x) {
    return String(~~x) === x && Number(x) >= 0;
};
exports.isIntegerString = isIntegerString;
const isString = function (x) {
    return Object.prototype.toString.call(x) === '[object String]';
};
exports.isString = isString;
const isDate = function (x) {
    return Object.prototype.toString.call(x) === '[object Date]';
};
exports.isDate = isDate;
const isEmpty = function (obj) {
    return Object.keys(obj).length === 0;
};
exports.isEmpty = isEmpty;
const hasOwnProperty = Object.prototype.hasOwnProperty;
const getCircularPath = function (obj, path, seen) {
    seen || (seen = new Set([obj]));
    path || (path = '');
    for (const key in obj) {
        const currentPath = path ? `${path}.${key}` : key;
        const value = obj[key];
        if ((0, exports.isObjectLike)(value)) {
            if (seen.has(value)) {
                return `${path}.${key}:<Circular>`;
            }
            else {
                seen.add(value);
                return (0, exports.getCircularPath)(value, currentPath, seen);
            }
        }
    }
    return null;
};
exports.getCircularPath = getCircularPath;
const _cloneDeep = function (obj) {
    if (!(0, exports.isObjectLike)(obj)) {
        return obj;
    }
    if ((0, exports.isDate)(obj)) {
        return new Date(+obj);
    }
    const newObj = (0, exports.isArray)(obj) ? [] : {};
    for (const key in obj) {
        const value = obj[key];
        newObj[key] = (0, exports._cloneDeep)(value);
    }
    return newObj;
};
exports._cloneDeep = _cloneDeep;
const cloneDeep = function (obj) {
    const path = (0, exports.getCircularPath)(obj);
    if (path) {
        throw new Error(`${constants_1.PACKAGE_NAME}: circular dependency detected under the path '${path}' of object you're trying to persist: ${obj}`);
    }
    return (0, exports._cloneDeep)(obj);
};
exports.cloneDeep = cloneDeep;
const difference = function (base, newValue) {
    if (base === newValue) {
        return {};
    }
    if (!(0, exports.isObjectLike)(base) || !(0, exports.isObjectLike)(newValue)) {
        return newValue;
    }
    const l = (0, exports.cloneDeep)(base);
    const r = (0, exports.cloneDeep)(newValue);
    const deletedValues = Object.keys(l).reduce((acc, key) => {
        if (hasOwnProperty.call(r, key)) {
            return acc;
        }
        acc[key] = undefined;
        return acc;
    }, {});
    if ((0, exports.isDate)(l) || (0, exports.isDate)(r)) {
        if (l.valueOf() === r.valueOf()) {
            return {};
        }
        return r;
    }
    const result = Object.keys(r).reduce((acc, key) => {
        if (!hasOwnProperty.call(l, key)) {
            acc[key] = r[key];
            return acc;
        }
        const diff = (0, exports.difference)(l[key], r[key]);
        if ((0, exports.isObjectLike)(diff) && (0, exports.isEmpty)(diff) && !(0, exports.isDate)(diff)) {
            if (((0, exports.isArray)(l) && !(0, exports.isArray)(r)) || (!(0, exports.isArray)(l) && (0, exports.isArray)(r))) {
                return r;
            }
            return acc;
        }
        acc[key] = diff;
        return acc;
    }, deletedValues);
    delete result._persist;
    return result;
};
exports.difference = difference;
const path = function (obj, pathArray) {
    return pathArray.reduce((acc, curr) => {
        if (acc) {
            const parsedCurr = parseInt(curr, 10);
            const index = (0, exports.isIntegerString)(curr) && parsedCurr < 0 ? acc.length + parsedCurr : curr;
            return (0, exports.isString)(acc) ? acc.charAt(index) : acc[index];
        }
    }, obj);
};
exports.path = path;
const assocPath = function (path, value) {
    const pathArray = [...path].reverse();
    const result = pathArray.reduce((acc, curr, index) => {
        const placeholder = (0, exports.isIntegerString)(curr) ? [] : {};
        placeholder[curr] = index === 0 ? value : acc;
        return placeholder;
    }, {});
    return result;
};
exports.assocPath = assocPath;
const dissocPath = function (obj, pathArray) {
    const clone = (0, exports.cloneDeep)(obj);
    pathArray.reduce((acc, curr, index) => {
        if (index === pathArray.length - 1 && acc) {
            if ((0, exports.isObjectLike)(acc)) {
                delete acc[curr];
            }
        }
        return acc && acc[curr];
    }, clone);
    return clone;
};
exports.dissocPath = dissocPath;
const _mergeDeep = function (options, target, ...sources) {
    if (!sources || !sources.length) {
        return target;
    }
    const source = sources.shift();
    const { preservePlaceholder, preserveUndefined } = options;
    if ((0, exports.isObjectLike)(target) && (0, exports.isObjectLike)(source)) {
        for (const key in source) {
            if ((0, exports.isObjectLike)(source[key]) && (0, exports.isObjectLike)(target[key])) {
                if (!target[key]) {
                    target[key] = {};
                }
                _mergeDeep(options, target[key], source[key]);
            }
            else {
                if ((0, exports.isArray)(target)) {
                    let sourceValue = source[key];
                    const placeholder = preservePlaceholder ? constants_1.PLACEHOLDER_UNDEFINED : undefined;
                    if (!preserveUndefined) {
                        sourceValue = typeof sourceValue !== 'undefined' ? sourceValue : target[parseInt(key, 10)];
                    }
                    sourceValue = sourceValue !== constants_1.PLACEHOLDER_UNDEFINED ? sourceValue : placeholder;
                    target[parseInt(key, 10)] = sourceValue;
                }
                else {
                    const value = source[key] !== constants_1.PLACEHOLDER_UNDEFINED ? source[key] : undefined;
                    target[key] = value;
                }
            }
        }
    }
    return _mergeDeep(options, target, ...sources);
};
const mergeDeep = function (target, source, options) {
    return _mergeDeep({
        preservePlaceholder: options === null || options === void 0 ? void 0 : options.preservePlaceholder,
        preserveUndefined: options === null || options === void 0 ? void 0 : options.preserveUndefined,
    }, (0, exports.cloneDeep)(target), (0, exports.cloneDeep)(source));
};
exports.mergeDeep = mergeDeep;
const _preserveUndefined = function (obj, pathsArray = [], type, prevPath, preserveAsPlaceholder) {
    if (!(0, exports.isObjectLike)(obj)) {
        return obj;
    }
    for (const key in obj) {
        const value = obj[key];
        const belongsToArray = (0, exports.isArray)(obj);
        const pathString = prevPath ? prevPath + '.' + key : key;
        if (value === null &&
            ((type === types_1.ConfigType.WHITELIST && pathsArray.indexOf(pathString) === -1) ||
                (type === types_1.ConfigType.BLACKLIST && pathsArray.indexOf(pathString) !== -1)) &&
            belongsToArray) {
            obj[parseInt(key, 10)] = undefined;
        }
        if (value === undefined &&
            preserveAsPlaceholder &&
            type === types_1.ConfigType.BLACKLIST &&
            pathsArray.indexOf(pathString) === -1 &&
            belongsToArray) {
            obj[parseInt(key, 10)] = constants_1.PLACEHOLDER_UNDEFINED;
        }
        _preserveUndefined(value, pathsArray, type, pathString, preserveAsPlaceholder);
    }
};
const preserveUndefined = function (outboundState, pathsArray, type, preserveAsPlaceholder) {
    const clone = (0, exports.cloneDeep)(outboundState);
    _preserveUndefined(clone, pathsArray, type, '', preserveAsPlaceholder);
    return clone;
};
exports.preserveUndefined = preserveUndefined;
const unique = function (value, index, self) {
    return self.indexOf(value) === index;
};
exports.unique = unique;
const findDuplicatesAndSubsets = function (list) {
    return list.reduce((entities, path) => {
        const filteredDuplicates = list.filter((inner) => inner === path);
        const filteredSubsets = list.filter((inner) => {
            return (path + '.').indexOf(inner + '.') === 0;
        });
        const { duplicates, subsets } = entities;
        const foundDuplicates = filteredDuplicates.length > 1 && duplicates.indexOf(path) === -1;
        const foundSubsets = filteredSubsets.length > 1;
        return {
            duplicates: [...duplicates, ...(foundDuplicates ? filteredDuplicates : [])],
            subsets: [...subsets, ...(foundSubsets ? filteredSubsets : [])].filter(exports.unique).sort(),
        };
    }, {
        duplicates: [],
        subsets: [],
    });
};
exports.findDuplicatesAndSubsets = findDuplicatesAndSubsets;
const singleTransformValidator = function (config, name, type) {
    const listType = type === types_1.ConfigType.WHITELIST ? 'whitelist' : 'blacklist';
    const commonErrorMsg1 = `${constants_1.PACKAGE_NAME}: incorrect ${listType} configuration.`;
    const commonErrorMsg2 = `Check your create${type === types_1.ConfigType.WHITELIST ? 'White' : 'Black'}list arguments.\n\n`;
    if (!(0, exports.isString)(name) || name.length < 1) {
        throw new Error(`${commonErrorMsg1} Name (key) of reducer is required. ${commonErrorMsg2}`);
    }
    if (!config || !config.length) {
        return;
    }
    const { duplicates, subsets } = (0, exports.findDuplicatesAndSubsets)(config);
    if (duplicates.length > 1) {
        throw new Error(`${commonErrorMsg1} Duplicated paths.\n\n ${JSON.stringify(duplicates)}\n\n ${commonErrorMsg2}`);
    }
    if (subsets.length > 1) {
        throw new Error(`${commonErrorMsg1} You are trying to persist an entire property and also some of its subset.\n\n${JSON.stringify(subsets)}\n\n ${commonErrorMsg2}`);
    }
};
exports.singleTransformValidator = singleTransformValidator;
const transformsValidator = function (transforms) {
    if (!(0, exports.isArray)(transforms)) {
        return;
    }
    const keys = (transforms === null || transforms === void 0 ? void 0 : transforms.map((t) => t.deepPersistKey).filter((k) => k)) || [];
    if (keys.length) {
        const duplicates = keys.filter((key, index) => keys.indexOf(key) !== index);
        if (duplicates.length) {
            throw new Error(`${constants_1.PACKAGE_NAME}: found duplicated keys in transforms creators. You can createWhitelist or createBlacklist for a specific root reducer key only once. Duplicated keys among createWhitelist and createBlacklist transforms are not allowed.\n\n Duplicates: ${JSON.stringify(duplicates)}`);
        }
    }
};
exports.transformsValidator = transformsValidator;
const configValidator = function ({ whitelist, blacklist }) {
    if (whitelist && whitelist.length && blacklist && blacklist.length) {
        throw new Error(`${constants_1.PACKAGE_NAME}: you should not define a whitelist and blacklist in parallel. It is allowed to use only one of these lists per config.`);
    }
    if (whitelist) {
        const { duplicates, subsets } = (0, exports.findDuplicatesAndSubsets)(whitelist);
        (0, exports.throwError)({ duplicates, subsets }, 'whitelist');
    }
    if (blacklist) {
        const { duplicates, subsets } = (0, exports.findDuplicatesAndSubsets)(blacklist);
        (0, exports.throwError)({ duplicates, subsets }, 'blacklist');
    }
};
exports.configValidator = configValidator;
const throwError = function ({ duplicates, subsets }, listType) {
    if (duplicates.length) {
        throw new Error(`${constants_1.PACKAGE_NAME}: duplicates of paths found in your ${listType}.\n\n ${JSON.stringify(duplicates)}`);
    }
    if (subsets.length) {
        throw new Error(`${constants_1.PACKAGE_NAME}: subsets of some parent keys found in your ${listType}. You must decide if you want to persist an entire path or its specific subset.\n\n ${JSON.stringify(subsets)}`);
    }
};
exports.throwError = throwError;
const getRootKeysGroup = function (list) {
    if (!(0, exports.isArray)(list)) {
        return [];
    }
    return list.filter(exports.unique).reduce((acc, curr) => {
        const pathArray = curr.split('.');
        const rootKey = pathArray[0];
        const path = pathArray.slice(1).join('.') || undefined;
        const existingElement = acc.filter((entity) => {
            const key = Object.keys(entity)[0];
            return key === rootKey;
        })[0];
        const existingValue = existingElement ? Object.values(existingElement)[0] : undefined;
        if (!existingElement) {
            acc.push({
                [rootKey]: path ? [path] : undefined,
            });
        }
        if (existingElement && !existingValue && path) {
            existingElement[rootKey] = [path];
        }
        if (existingElement && existingValue && path) {
            existingValue.push(path);
        }
        return acc;
    }, []);
};
exports.getRootKeysGroup = getRootKeysGroup;
//# sourceMappingURL=index.js.map