"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPersistConfig = exports.getTransforms = exports.createBlacklist = exports.createWhitelist = exports.autoMergeDeep = void 0;
const utils_1 = require("./utils");
const constants_1 = require("./constants");
const types_1 = require("./types");
const createTransform = function (inbound, outbound, config = {}) {
    const whitelist = config.whitelist || null;
    const blacklist = config.blacklist || null;
    function whitelistBlacklistCheck(key) {
        if (whitelist && whitelist.indexOf(key) === -1)
            return true;
        if (blacklist && blacklist.indexOf(key) !== -1)
            return true;
        return false;
    }
    return {
        in: (state, key, fullState) => !whitelistBlacklistCheck(key) && inbound ? inbound(state, key, fullState) : state,
        out: (state, key, fullState) => !whitelistBlacklistCheck(key) && outbound ? outbound(state, key, fullState) : state,
        deepPersistKey: whitelist && whitelist[0],
    };
};
const autoMergeDeep = (inboundState, originalState, reducedState, { debug, whitelist, blacklist, transforms }) => {
    if (whitelist || blacklist) {
        throw new Error('State reconciler autoMergeDeep uses custom transforms instead of old whitelist or blacklist config properties. Please use createWhitelist or createBlacklist transforms.');
    }
    (0, utils_1.transformsValidator)(transforms);
    const newState = (0, utils_1.cloneDeep)(reducedState);
    let toRehydrateState = inboundState;
    if (toRehydrateState && (0, utils_1.isObjectLike)(toRehydrateState)) {
        const diff = (0, utils_1.difference)(originalState, reducedState);
        if (!(0, utils_1.isEmpty)(diff)) {
            toRehydrateState = (0, utils_1.mergeDeep)(inboundState, diff, { preserveUndefined: true });
            if (debug) {
                console.log(`${constants_1.PACKAGE_NAME}/autoMergeDeep: sub state of your state was modified by reducer during rehydration. Values from reducer will be kept: ${JSON.stringify(diff)}`);
            }
        }
        Object.keys(toRehydrateState).forEach((key) => {
            if (key === '_persist') {
                return;
            }
            if ((0, utils_1.isObjectLike)(newState[key])) {
                newState[key] = (0, utils_1.mergeDeep)(newState[key], toRehydrateState[key]);
                return;
            }
            newState[key] = toRehydrateState[key];
        });
    }
    if (debug && toRehydrateState && (0, utils_1.isObjectLike)(toRehydrateState)) {
        console.log(`${constants_1.PACKAGE_NAME}/autoMergeDeep: rehydrated keys ${JSON.stringify(toRehydrateState)}`);
    }
    return newState;
};
exports.autoMergeDeep = autoMergeDeep;
const createWhitelist = (key, whitelist) => {
    (0, utils_1.singleTransformValidator)(whitelist, key, types_1.ConfigType.WHITELIST);
    return createTransform((inboundState) => {
        if (!whitelist || !whitelist.length) {
            return inboundState;
        }
        let inboundToPersist = null;
        let value;
        whitelist.forEach((statePath) => {
            const pathArray = statePath.split('.');
            value = (0, utils_1.path)(inboundState, pathArray);
            if (typeof value === 'undefined' && (0, utils_1.isIntegerString)(pathArray[pathArray.length - 1])) {
                value = constants_1.PLACEHOLDER_UNDEFINED;
            }
            const assocResult = (0, utils_1.assocPath)(pathArray, value);
            const initial = (0, utils_1.isArray)(assocResult) ? [] : {};
            inboundToPersist = (0, utils_1.mergeDeep)(!inboundToPersist ? initial : inboundToPersist, assocResult, {
                preservePlaceholder: true,
            });
        });
        return inboundToPersist || inboundState;
    }, (outboundState) => {
        return (0, utils_1.preserveUndefined)(outboundState, whitelist, types_1.ConfigType.WHITELIST);
    }, {
        whitelist: [key],
    });
};
exports.createWhitelist = createWhitelist;
const createBlacklist = (key, blacklist) => {
    (0, utils_1.singleTransformValidator)(blacklist, key, types_1.ConfigType.BLACKLIST);
    return createTransform((inboundState) => {
        if (!blacklist || !blacklist.length) {
            return;
        }
        const inboundToPersist = (0, utils_1.preserveUndefined)(inboundState, blacklist, types_1.ConfigType.BLACKLIST, true);
        const paths = blacklist.map((statePath) => statePath.split('.'));
        return paths.reduce((inboundToPersist, pathArray) => {
            return (0, utils_1.dissocPath)(inboundToPersist, pathArray);
        }, inboundToPersist);
    }, (outboundState) => {
        return (0, utils_1.preserveUndefined)(outboundState, blacklist, types_1.ConfigType.BLACKLIST);
    }, {
        whitelist: [key],
    });
};
exports.createBlacklist = createBlacklist;
const getTransforms = function (type, list) {
    return list.map((rootObject) => {
        const key = Object.keys(rootObject)[0];
        const paths = rootObject[key];
        return type === types_1.ConfigType.WHITELIST ? (0, exports.createWhitelist)(key, paths) : (0, exports.createBlacklist)(key, paths);
    });
};
exports.getTransforms = getTransforms;
const getPersistConfig = (_a) => {
    var { key, whitelist, blacklist, storage, transforms, rootReducer } = _a, rest = __rest(_a, ["key", "whitelist", "blacklist", "storage", "transforms", "rootReducer"]);
    (0, utils_1.configValidator)({ whitelist, blacklist });
    const whitelistByRootKeys = (0, utils_1.getRootKeysGroup)(whitelist);
    const blacklistByRootKeys = (0, utils_1.getRootKeysGroup)(blacklist);
    const allRootKeys = Object.keys(rootReducer(undefined, { type: '' }));
    const whitelistRootKeys = whitelistByRootKeys.map((rootObject) => Object.keys(rootObject)[0]);
    const blacklistRootKeys = blacklistByRootKeys.map((rootObject) => Object.keys(rootObject)[0]);
    const keysToExclude = allRootKeys.filter((k) => whitelistRootKeys.indexOf(k) === -1 && blacklistRootKeys.indexOf(k) === -1);
    const whitelistTransforms = (0, exports.getTransforms)(types_1.ConfigType.WHITELIST, whitelistByRootKeys);
    const blacklistTransforms = (0, exports.getTransforms)(types_1.ConfigType.BLACKLIST, blacklistByRootKeys);
    const excludedKeysTransforms = (0, utils_1.isArray)(whitelist) ? keysToExclude.map((key) => (0, exports.createBlacklist)(key)) : [];
    return Object.assign(Object.assign({}, rest), { key,
        storage, transforms: [
            ...whitelistTransforms,
            ...blacklistTransforms,
            ...excludedKeysTransforms,
            ...(transforms ? transforms : []),
        ], stateReconciler: exports.autoMergeDeep });
};
exports.getPersistConfig = getPersistConfig;
//# sourceMappingURL=index.js.map